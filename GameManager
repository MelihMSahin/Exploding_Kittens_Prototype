from TurnOrderEnum import TurnOrderEnum
from Player import Player
from Deck import Deck
from InputSystem import InputSystem


class GameManager():
    def __init__(self):
        self.turn_order = TurnOrderEnum.initialise_game
        self.no_of_players = self._no_of_players()
        self.players = [Player(i) for i in range(0, self.no_of_players)]
        self.deck = Deck(self.no_of_players)

        self._give_initial_defuse()
        self._deal_cards()
        self.deck._shuffle_deck()

        self.turn_order = TurnOrderEnum.choose_next_player
        self.next_player_index = -1
        self.is_attacking = False
        self.under_attack = False

    def _no_of_players(self):
        return 2  # Only 2 players for MonteCarlo's initial testing

    def _give_initial_defuse(self):
        for player in self.players:
            self.deck.give_initial_defuse(player)

    def _deal_cards(self):
        for _ in range(7):
            for player in self.players:
                player.draw(self.deck.draw_card())

    def _next_player(self):
        if self.under_attack and (not self.is_attacking):
            self.under_attack = False
            return self.next_player_index % self.no_of_players

        if self.is_attacking:
            self.under_attack = True
            self.is_attacking = False

        self.next_player_index += 1
        while not self.players[self.next_player_index].is_alive:
            self.next_player_index += 1
        return self.next_player_index % self.no_of_players

    def game_loop(self):
        while True:
            if self.turn_order == TurnOrderEnum.choose_next_player:
                self.next_player_index = self._next_player()
                self.turn_order = TurnOrderEnum.play_actions

            if self.turn_order == TurnOrderEnum.play_actions:
                self._play_actions()

    def _play_actions(self):
        while self.turn_order == TurnOrderEnum.play_actions:
            print(f"it is plyer{self.next_player_index}'s turn")

            card_to_play = InputSystem.pick_action(
                self.players[self.next_player_index])

            # check if card_to_play is valid

            match card_to_play:
                case -1:  # no action
                    exploding_kitten_position = self.players[self.next_player_index].draw(
                        self.draw_card())
                    if exploding_kitten_position >= 0:
                        self._place_exploding_kitten(exploding_kitten_position)
                    elif exploding_kitten_position == -2:
                        self.players[self.next_player_index] = False
                        count = 0
                        for i in self.players:
                            if i != False:
                                count += 1
                        if count <= 1:
                            print("Game has ended.")
                    self.turn_order = TurnOrderEnum.choose_next_player
                    break
                case 3:
                    self._attack()
                    break
                case 4:
                    self._skip()
                    break
                case 5:
                    self._favor()
                case 6:
                    self._shuffle()
                case 7:
                    self._see_the_future()
                case 8:
                    self._steal(8)
                case 9:
                    self._steal(9)
                case 10:
                    self._steal(10)
                case 11:
                    self._steal(11)
                case 12:
                    self._steal(12)
